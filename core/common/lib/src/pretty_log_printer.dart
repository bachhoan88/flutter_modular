import 'dart:convert';

import 'package:logger/logger.dart';

class PrettyLogPrinter extends LogPrinter {
  static final levelColors = {
    Level.debug: const AnsiColor.none(),
    Level.info: const AnsiColor.fg(12),
    Level.warning: const AnsiColor.fg(208),
    Level.error: const AnsiColor.fg(196),
  };

  /// Matches a stacktrace line as generated on Android/iOS devices.
  /// For example:
  /// #1      Logger.log (package:logger/src/logger.dart:115:29)
  static final _deviceStackTraceRegex = RegExp(r'#[0-9]+\s+(.+) \((\S+)\)');

  /// Matches a stacktrace line as generated by Flutter web.
  /// For example:
  /// packages/logger/src/printers/pretty_printer.dart 91:37
  static final _webStackTraceRegex = RegExp(r'^((packages|dart-sdk)/\S+/)');

  /// Matches a stacktrace line as generated by browser Dart.
  /// For example:
  /// dart:sdk_internal
  /// package:logger/src/logger.dart
  static final _browserStackTraceRegex =
      RegExp(r'^(?:package:)?(dart:\S+|\S+)');

  static final _stackTraceLineRegex = RegExp(r'^(.*) \((.*)\)');

  final int methodCount = 1;
  final int errorMethodCount = 8;
  final int lineLength;
  final bool colors;
  final bool printCodeLine;

  PrettyLogPrinter({
    this.lineLength = 120,
    this.colors = true,
    this.printCodeLine = false,
  });

  @override
  List<String> log(LogEvent event) {
    final messageStr = stringifyMessage(event.message);
    final origin = getOrigin();

    String? stackTraceStr;
    if (event.stackTrace != null) {
      stackTraceStr = formatStackTrace(event.stackTrace!, errorMethodCount);
    }

    final errorStr = event.error?.toString();

    return _formatAndPrint(
      event.level,
      messageStr,
      getTime(),
      origin,
      errorStr,
      stackTraceStr,
    );
  }

  String getOrigin() {
    final lines = StackTrace.current.toString().split('\n');
    final source = StringBuffer();

    var count = 0;
    for (var line in lines) {
      if (_discardDeviceStacktraceLine(line) ||
          _discardWebStacktraceLine(line) ||
          _discardBrowserStacktraceLine(line)) {
        continue;
      }
      source.write(line.replaceFirst(RegExp(r'#\d+\s+'), ''));
      if (++count == 1) {
        break;
      }
    }
    return source.toString();
  }

  String? formatStackTrace(StackTrace stackTrace, int methodCount) {
    final lines = stackTrace.toString().split('\n');
    final formatted = <String>[];
    var count = 0;
    for (var line in lines) {
      if (_discardDeviceStacktraceLine(line) ||
          _discardWebStacktraceLine(line) ||
          _discardBrowserStacktraceLine(line)) {
        continue;
      }
      formatted.add('#$count   ${line.replaceFirst(RegExp(r'#\d+\s+'), '')}');
      if (++count == methodCount) {
        break;
      }
    }

    if (formatted.isEmpty) {
      return null;
    } else {
      return formatted.join('\n');
    }
  }

  bool _discardDeviceStacktraceLine(String line) {
    final match = _deviceStackTraceRegex.matchAsPrefix(line);
    if (match == null) {
      return false;
    }
    return match.group(2)?.startsWith('package:logger') == true ||
        match.group(2)?.startsWith('package:common/pretty_log_printer.dart') ==
            true;
  }

  bool _discardWebStacktraceLine(String line) {
    final match = _webStackTraceRegex.matchAsPrefix(line);
    if (match == null) {
      return false;
    }
    return match.group(1)?.startsWith('packages/logger') == true ||
        match.group(1)?.startsWith('package/common/pretty_log_printer.dart') ==
            true ||
        match.group(1)?.startsWith('dart-sdk/lib') == true;
  }

  bool _discardBrowserStacktraceLine(String line) {
    final match = _browserStackTraceRegex.matchAsPrefix(line);
    if (match == null) {
      return false;
    }
    return match.group(1)?.startsWith('package:logger') == true ||
        match.group(1)?.startsWith('package:common/pretty_log_printer.dart') ==
            true ||
        match.group(1)?.startsWith('dart:') == true;
  }

  String _method(String line) {
    final match = _stackTraceLineRegex.matchAsPrefix(line);
    return match?.group(1) ?? '';
  }

  String _codeLine(String line) {
    final match = _stackTraceLineRegex.matchAsPrefix(line);
    return match?.group(2) ?? '';
  }

  String getTime() {
    String threeDigits(int n) {
      if (n >= 100) return '$n';
      if (n >= 10) return '0$n';
      return '00$n';
    }

    String twoDigits(int n) {
      if (n >= 10) return '$n';
      return '0$n';
    }

    final now = DateTime.now();
    final h = twoDigits(now.hour);
    final min = twoDigits(now.minute);
    final sec = twoDigits(now.second);
    final ms = threeDigits(now.millisecond);
    return '$h:$min:$sec.$ms';
  }

  String stringifyMessage(dynamic message) {
    if (message is Map || message is Iterable) {
      const encoder = JsonEncoder.withIndent('  ');
      return encoder.convert(message);
    } else {
      return message.toString();
    }
  }

  AnsiColor _getLevelColor(Level level) {
    if (colors) {
      return levelColors[level] ?? const AnsiColor.none();
    } else {
      return const AnsiColor.none();
    }
  }

  AnsiColor _getErrorColor(Level level) {
    if (colors) {
      return (levelColors[Level.error] ?? const AnsiColor.none()).toBg();
    } else {
      return const AnsiColor.none();
    }
  }

  List<String> _formatAndPrint(
    Level level,
    String message,
    String time,
    String origin,
    String? error,
    String? stacktrace,
  ) {
    List<String> buffer = [];
    final color = _getLevelColor(level);

    buffer.add(color(
        '$time ${_method(origin)} $message ${printCodeLine ? _codeLine(origin) : ''}'));

    if (error != null) {
      final errorColor = _getErrorColor(level);
      for (var line in error.split('\n')) {
        buffer.add(
            '$time ${errorColor.resetForeground}${errorColor(line)}${errorColor.resetBackground}');
      }
    }

    if (stacktrace != null) {
      for (var line in stacktrace.split('\n')) {
        buffer.add('$time $color $line');
      }
    }

    return buffer;
  }
}
